<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="theme-color" content="#000814">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>KC3EFJ</title>
    <style>
        html, body {
            height: 100dvh;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            background: linear-gradient(to bottom, #0a0015, #000814);
            font-family: 'Courier New', Courier, monospace;
            color: #e0f7ff;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            touch-action: manipulation;
            cursor: default;
            -webkit-tap-highlight-color: transparent;
        }
        .callsign-container,
        .callsign {
            cursor: pointer;
        }
        canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: auto;
        }
        .content-wrapper {
            pointer-events: none;
            z-index: 2;
            position: relative;
            width: 100%;
            max-width: 90vw;
            padding: 20px;
            text-align: center;
            min-height: 60dvh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .blurb,
        .callsign-container {
            pointer-events: auto;
        }
        .callsign-container {
            transition: transform 0.6s cubic-bezier(0.22, 1, 0.36, 1);
            will-change: transform;
        }
        .callsign-container.expanded {
            transform: translateY(-240px);
        }
        .callsign {
            font-size: clamp(3rem, 12vw, 6rem);
            letter-spacing: 0.6rem;
            font-weight: bold;
            text-shadow: 
                0 0 10px #ff00ff,
                0 0 25px #00ffff,
                0 0 40px #ff00ff;
            margin: 0;
            transition: transform 0.4s ease, text-shadow 0.4s ease;
        }
        .callsign:hover, .callsign:active {
            transform: scale(1.04);
            text-shadow: 
                0 0 20px #ff00ff,
                0 0 40px #00ffff,
                0 0 60px #ff00ff;
        }
        .blurb {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) translateY(80px);
            opacity: 0;
            visibility: hidden;
            width: 90%;
            max-width: 600px;
            padding: clamp(1rem, 4vw, 1.8rem) clamp(1.2rem, 5vw, 2rem);
            background: rgba(10, 25, 50, 0.02);
            border-radius: 16px;
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(0, 255, 255, 0.15);
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            font-size: clamp(0.9rem, 3.2vw, 1.25rem);
            line-height: 1.5;
            text-align: center;
            text-shadow: 0 0 6px #00ffff;
            transition: opacity 0.6s ease-out, transform 0.6s cubic-bezier(0.22, 1, 0.36, 1);
            will-change: opacity, transform;
            pointer-events: auto;
            user-select: text;
            -webkit-user-select: text;
            cursor: text;
        }
        .blurb.visible {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -50%) translateY(0);
        }
        .blurb strong {
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }
        .blurb strong a,
        .blurb a strong {
            color: inherit;
            text-decoration: none;
        }
        @media (max-width: 600px) {
            .callsign-container.expanded { transform: translateY(-180px); }
            .callsign { letter-spacing: 0.4rem; }
            .blurb { padding: clamp(0.9rem, 4vw, 1.4rem) clamp(1rem, 4.5vw, 1.6rem); }
        }
        @media (max-width: 400px) {
            .blurb {
                font-size: clamp(0.85rem, 3.8vw, 1rem);
                padding: 0.8rem 1.2rem;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="content-wrapper" id="wrapper">
        <div class="callsign-container" id="callsignContainer">
            <div class="callsign" id="callsign">KC3EFJ</div>
        </div>
        <div class="blurb" id="blurb">
            Amateur Radio Operator<br>
            Based in <strong>Port Saint John</strong> (Cocoa), Florida.<br><br>
            Name: <strong>Jeff Hopkins</strong><br>
            Callsign: <strong>KC3EFJ</strong><br>
            Interests: Digital Modes, APRS, Meshtastic, Eurorack<br><br>
            Email: <strong><a href="mailto:jeff.m.hopkins+kc3efj@gmail.com">jeff.m.hopkins+kc3efj@gmail.com</a></strong><br>
            Github: <strong><a href="https://github.com/jeffmhopkins/">https://github.com/jeffmhopkins/</a></strong>
        </div>
    </div>

    <script>
        (function() {
            // ────────────────────────────────────────────────
            //  EASILY ADJUSTABLE SETTINGS
            // ────────────────────────────────────────────────

            const BASE_NODE_COUNT_DESKTOP = 150;
            const BASE_NODE_COUNT_MOBILE  = 150;
            const MIN_NODES               = 30;
            const MAX_NODES               = 400;

            const NODE_SPEED_DESKTOP      = 0.5;
            const NODE_SPEED_MOBILE       = 0.5;

            const NODE_RADIUS_PX          = 2.2;   // increased slightly for better visibility with SDF

            const LINE_THICKNESS_PX       = 1.01;
            const CONNECTION_DISTANCE_DESKTOP = 210;
            const CONNECTION_DISTANCE_MOBILE  = 210;

            const STATIC_LINE_ALPHA_BASE  = 0.65;
            const MOUSE_LINE_ALPHA_BASE   = 0.85;

            const HUE_RANGE_1_START       = 180;
            const HUE_RANGE_1_WIDTH       = 30;
            const HUE_RANGE_2_START       = 240;
            const HUE_RANGE_2_WIDTH       = 60;
            const HUE_RANGE_3_START       = 270;
            const HUE_RANGE_3_WIDTH       = 30;

            const SATURATION_BASE         = 0.5;
            const SATURATION_VARIANCE     = 1.0;

            const SIGNAL_SPEED            = 200;
            const FLOOD_HEAD_SIZE         = 7;
            const FLOOD_LINE_PULSE_SPEED  = 0.008;
            const FLOOD_HEAD_PULSE_SPEED  = 0.012;

            const CLEAR_ALPHA             = 0.09;
            const CLICK_SNAP_DISTANCE_SQ  = 60 * 60;

            // ────────────────────────────────────────────────

            const callsign = document.getElementById('callsign');
            const callsignContainer = document.getElementById('callsignContainer');
            const blurb = document.getElementById('blurb');

            function toggleBlurb(e) {
                e.preventDefault();
                e.stopPropagation();
                blurb.classList.toggle('visible');
                callsignContainer.classList.toggle('expanded');
            }

            callsign.addEventListener('click', toggleBlurb);
            callsign.addEventListener('touchstart', toggleBlurb, { passive: false });

            blurb.addEventListener('click', e => e.stopPropagation());
            blurb.addEventListener('touchstart', e => e.stopPropagation(), { passive: true });

            const canvas = document.getElementById('canvas');
            const gl = canvas.getContext('webgl');
            if (!gl) {
                console.error('WebGL not supported');
                return;
            }

            let width, height, dpr, particles = [], isMobile = false;
            let mouseX = -1000, mouseY = -1000;
            let signals = [];
            let activated = new Set();

            document.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
            document.addEventListener('touchmove', e => {
                if (e.touches.length > 0) {
                    mouseX = e.touches[0].clientX;
                    mouseY = e.touches[0].clientY;
                }
            }, { passive: true });
            document.addEventListener('touchstart', e => {
                if (e.touches.length > 0) {
                    mouseX = e.touches[0].clientX;
                    mouseY = e.touches[0].clientY;
                }
            }, { passive: true });

            const baseWidth = 1920, baseHeight = 1080;
            const baseDensityDesktop = BASE_NODE_COUNT_DESKTOP / (baseWidth * baseHeight);
            const baseDensityMobile  = BASE_NODE_COUNT_MOBILE  / (baseWidth * baseHeight);

            let particleProgram, lineProgram;
            let particlePositionBuffer, particleColorBuffer, particleCenterBuffer;
            let linePositionBuffer, lineAlphaBuffer;

            function createShadersAndPrograms() {
                // Vertex shader – fixed center projection
                const vsSource = `
                    attribute vec2 aPosition;
                    attribute vec4 aColor;
                    attribute vec2 aCenter;
                    varying vec4 vColor;
                    varying vec2 vCenter;
                    uniform mat3 uProjection;
                    void main() {
                        vec3 pos3 = uProjection * vec3(aPosition, 1.0);
                        gl_Position = vec4(pos3.xy, 0.0, 1.0);
                        vColor = aColor;

                        vec3 centerProj = uProjection * vec3(aCenter, 1.0);
                        vec2 ndc = centerProj.xy;
                        vCenter = (ndc * 0.5 + 0.5) * vec2(${width}, ${height});
                    }
                `;

                const fsSource = `
                    precision mediump float;
                    varying vec4 vColor;
                    varying vec2 vCenter;
                    void main() {
                        vec2 delta = gl_FragCoord.xy - vCenter;
                        float distSq = dot(delta, delta);
                        float r = ${NODE_RADIUS_PX * dpr};
                        float rSq = r * r;
                        float softness = 3.0;           // tweak for smoother edge
                        float alpha = 1.0 - smoothstep(rSq - softness, rSq + softness, distSq);
                        if (alpha < 0.02) discard;
                        gl_FragColor = vec4(vColor.rgb, alpha * vColor.a);
                    }
                `;

                const lineVsSource = `
                    attribute vec2 aPosition;
                    attribute float aAlpha;
                    varying float vAlpha;
                    uniform mat3 uProjection;
                    void main() {
                        vec3 pos3 = uProjection * vec3(aPosition, 1.0);
                        gl_Position = vec4(pos3.xy, 0.0, 1.0);
                        vAlpha = aAlpha;
                    }
                `;

                const lineFsSource = `
                    precision mediump float;
                    varying float vAlpha;
                    uniform vec4 uColor;
                    void main() {
                        gl_FragColor = uColor * vec4(1.0, 1.0, 1.0, vAlpha);
                    }
                `;

                function createShader(type, source) {
                    const shader = gl.createShader(type);
                    gl.shaderSource(shader, source);
                    gl.compileShader(shader);
                    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                        console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                        gl.deleteShader(shader);
                        return null;
                    }
                    return shader;
                }

                function createProgram(vs, fs) {
                    const program = gl.createProgram();
                    gl.attachShader(program, vs);
                    gl.attachShader(program, fs);
                    gl.linkProgram(program);
                    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                        console.error('Program link error:', gl.getProgramInfoLog(program));
                        gl.deleteProgram(program);
                        return null;
                    }
                    return program;
                }

                const vs = createShader(gl.VERTEX_SHADER, vsSource);
                const fs = createShader(gl.FRAGMENT_SHADER, fsSource);
                particleProgram = createProgram(vs, fs);

                const lineVs = createShader(gl.VERTEX_SHADER, lineVsSource);
                const lineFs = createShader(gl.FRAGMENT_SHADER, lineFsSource);
                lineProgram = createProgram(lineVs, lineFs);

                if (!particleProgram || !lineProgram) {
                    console.error("Failed to create WebGL programs");
                }
            }

            function resize() {
                dpr = window.devicePixelRatio || 1;
                width = canvas.width = window.innerWidth * dpr;
                height = canvas.height = window.innerHeight * dpr;
                canvas.style.width = window.innerWidth + 'px';
                canvas.style.height = window.innerHeight + 'px';
                gl.viewport(0, 0, width, height);

                isMobile = window.innerWidth <= 768 || 'ontouchstart' in window;
                const density = isMobile ? baseDensityMobile : baseDensityDesktop;
                const count = Math.max(MIN_NODES, Math.min(MAX_NODES, Math.round(density * (window.innerWidth * window.innerHeight))));

                // Recreate shaders & programs with current dimensions
                createShadersAndPrograms();

                initParticles(count);

                // Re-create buffers on resize
                particlePositionBuffer = gl.createBuffer();
                particleColorBuffer    = gl.createBuffer();
                particleCenterBuffer   = gl.createBuffer();
                linePositionBuffer     = gl.createBuffer();
                lineAlphaBuffer        = gl.createBuffer();
            }

            function initParticles(count) {
                const nodeSpeed = isMobile ? NODE_SPEED_MOBILE : NODE_SPEED_DESKTOP;
                particles = Array.from({length: count}, () => {
                    const t = Math.random();
                    let hue;
                    if (t < 0.4) {
                        hue = HUE_RANGE_1_START + (t / 0.4) * HUE_RANGE_1_WIDTH;
                    } else if (t < 0.6) {
                        hue = HUE_RANGE_2_START + (t - 0.4) / 0.2 * HUE_RANGE_2_WIDTH;
                    } else {
                        hue = HUE_RANGE_3_START + ((t - 0.6) / 0.4) * HUE_RANGE_3_WIDTH;
                    }
                    const saturation = SATURATION_BASE + Math.abs(t - 0.5) * SATURATION_VARIANCE;
                    return {
                        x: Math.random() * window.innerWidth,
                        y: Math.random() * window.innerHeight,
                        vx: (Math.random() - 0.5) * nodeSpeed,
                        vy: (Math.random() - 0.5) * nodeSpeed,
                        hue: hue,
                        sat: saturation
                    };
                });
            }

            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

            function addThickLineVerts(x1, y1, x2, y2, thickness, alpha, outPositions, outAlphas) {
                const dx = x2 - x1;
                const dy = y2 - y1;
                const len = Math.hypot(dx, dy);
                if (len < 0.001) return;

                const ux = dx / len;
                const uy = dy / len;
                const px = -uy;
                const py = ux;

                const hx = px * (thickness / 2);
                const hy = py * (thickness / 2);

                const ax = x1 - hx, ay = y1 - hy;
                const bx = x1 + hx, by = y1 + hy;
                const cx = x2 + hx, cy = y2 + hy;
                const dx_ = x2 - hx, dy_ = y2 - hy;

                outPositions.push(ax, ay, bx, by, cx, cy);
                outPositions.push(ax, ay, cx, cy, dx_, dy_);

                for (let i = 0; i < 6; i++) outAlphas.push(alpha);
            }

            function addNodeQuad(x, y, radiusPx, r, g, b, a, outPositions, outColors, outCenters) {
                const rPx = radiusPx * dpr * 1.6; // margin for antialias/softness

                const left   = x - rPx;
                const right  = x + rPx;
                const top    = y - rPx;
                const bottom = y + rPx;

                outPositions.push(left, top, right, top, right, bottom);
                outPositions.push(left, top, right, bottom, left, bottom);

                for (let i = 0; i < 6; i++) {
                    outColors.push(r, g, b, a);
                    outCenters.push(x, y);
                }
            }

            let lastTime = 0;
            const targetFPS = isMobile ? 1000/45 : 1000/60;

            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                let minDist = Infinity;
                let closest = -1;
                particles.forEach((p, i) => {
                    const dx = p.x - clickX;
                    const dy = p.y - clickY;
                    const d2 = dx*dx + dy*dy;
                    if (d2 < minDist) {
                        minDist = d2;
                        closest = i;
                    }
                });
                if (minDist < CLICK_SNAP_DISTANCE_SQ) {
                    startFlood(closest);
                }
            });

            function startFlood(startIndex) {
                signals = [];
                activated = new Set([startIndex]);
                addSignalsFrom(startIndex, performance.now());
            }

            function addSignalsFrom(index, startTime) {
                const maxDist = isMobile ? CONNECTION_DISTANCE_MOBILE : CONNECTION_DISTANCE_DESKTOP;
                for (let j = 0; j < particles.length; j++) {
                    if (j === index || activated.has(j)) continue;
                    const dx = particles[index].x - particles[j].x;
                    const dy = particles[index].y - particles[j].y;
                    const dist = Math.hypot(dx, dy);
                    if (dist < maxDist) {
                        const duration = (dist / SIGNAL_SPEED) * 1000;
                        signals.push({
                            from: index,
                            to: j,
                            start_time: startTime,
                            duration: duration,
                            dist: dist
                        });
                    }
                }
            }

            function animate(time) {
                requestAnimationFrame(animate);
                if (!lastTime) lastTime = time;
                const delta = time - lastTime;
                if (delta < targetFPS) return;
                lastTime = time - (delta % targetFPS);

                gl.clearColor(0, 0, 20/255, CLEAR_ALPHA);
                gl.clear(gl.COLOR_BUFFER_BIT);

                particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    if (p.x < 0 || p.x > window.innerWidth) p.vx *= -1;
                    if (p.y < 0 || p.y > window.innerHeight) p.vy *= -1;
                });

                // Nodes (SDF circles)
                const nodePositions = [];
                const nodeColors = [];
                const nodeCenters = [];

                particles.forEach(p => {
                    const h = p.hue / 360;
                    const q = p.sat;
                    const p_ = 0.0;
                    const r = hue2rgb(p_, q, h + 1/3);
                    const g = hue2rgb(p_, q, h);
                    const b = hue2rgb(p_, q, h - 1/3);
                    const a = 1.0;

                    addNodeQuad(p.x, p.y, NODE_RADIUS_PX, r, g, b, a, nodePositions, nodeColors, nodeCenters);
                });

                if (nodePositions.length > 0 && particleProgram) {
                    gl.useProgram(particleProgram);
                    gl.uniformMatrix3fv(gl.getUniformLocation(particleProgram, 'uProjection'), false, getProjection());

                    gl.bindBuffer(gl.ARRAY_BUFFER, particlePositionBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(nodePositions), gl.DYNAMIC_DRAW);
                    const posLoc = gl.getAttribLocation(particleProgram, 'aPosition');
                    gl.enableVertexAttribArray(posLoc);
                    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, particleColorBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(nodeColors), gl.DYNAMIC_DRAW);
                    const colLoc = gl.getAttribLocation(particleProgram, 'aColor');
                    gl.enableVertexAttribArray(colLoc);
                    gl.vertexAttribPointer(colLoc, 4, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, particleCenterBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(nodeCenters), gl.DYNAMIC_DRAW);
                    const cenLoc = gl.getAttribLocation(particleProgram, 'aCenter');
                    gl.enableVertexAttribArray(cenLoc);
                    gl.vertexAttribPointer(cenLoc, 2, gl.FLOAT, false, 0, 0);

                    gl.drawArrays(gl.TRIANGLES, 0, nodePositions.length / 2);
                }

                // Static + mouse lines
                const maxDist = isMobile ? CONNECTION_DISTANCE_MOBILE : CONNECTION_DISTANCE_DESKTOP;
                const linePositions = [];
                const lineAlphas = [];

                for (let i = 0; i < particles.length; i++) {
                    for (let j = i + 1; j < particles.length; j++) {
                        const d = Math.hypot(particles[i].x - particles[j].x, particles[i].y - particles[j].y);
                        if (d < maxDist) {
                            const alpha = (1 - d / maxDist) ** 1.3 * STATIC_LINE_ALPHA_BASE;
                            addThickLineVerts(particles[i].x, particles[i].y, particles[j].x, particles[j].y,
                                              LINE_THICKNESS_PX * dpr, alpha, linePositions, lineAlphas);
                        }
                    }
                }

                if (mouseX >= 0 && mouseY >= 0 && mouseX <= window.innerWidth && mouseY <= window.innerHeight) {
                    for (let i = 0; i < particles.length; i++) {
                        const d = Math.hypot(mouseX - particles[i].x, mouseY - particles[i].y);
                        if (d < maxDist) {
                            const alpha = (1 - d / maxDist) ** 1.3 * MOUSE_LINE_ALPHA_BASE;
                            addThickLineVerts(mouseX, mouseY, particles[i].x, particles[i].y,
                                              LINE_THICKNESS_PX * dpr, alpha, linePositions, lineAlphas);
                        }
                    }
                }

                if (linePositions.length > 0 && lineProgram) {
                    gl.useProgram(lineProgram);
                    gl.uniformMatrix3fv(gl.getUniformLocation(lineProgram, 'uProjection'), false, getProjection());
                    gl.uniform4f(gl.getUniformLocation(lineProgram, 'uColor'), 0.7, 0.1, 0.9, 1.0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, linePositionBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(linePositions), gl.DYNAMIC_DRAW);
                    gl.enableVertexAttribArray(0);
                    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, lineAlphaBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lineAlphas), gl.DYNAMIC_DRAW);
                    gl.enableVertexAttribArray(1);
                    gl.vertexAttribPointer(1, 1, gl.FLOAT, false, 0, 0);

                    gl.drawArrays(gl.TRIANGLES, 0, linePositions.length / 2);
                }

                // Flood lines & heads
                let completed = [];
                signals = signals.filter(sig => {
                    const elapsed = time - sig.start_time;
                    if (elapsed > sig.duration) {
                        if (!activated.has(sig.to)) {
                            activated.add(sig.to);
                            completed.push({to: sig.to, arrival: sig.start_time + sig.duration});
                        }
                        return false;
                    }
                    return true;
                });

                completed.forEach(c => addSignalsFrom(c.to, c.arrival));

                const floodPositions = [];
                const floodAlphas = [];
                const headPositions = [];
                const headColors = [];
                const headCenters = [];

                signals.forEach(sig => {
                    let progress = (time - sig.start_time) / sig.duration;
                    progress = Math.min(1, Math.max(0, progress));

                    const fx = particles[sig.from].x;
                    const fy = particles[sig.from].y;
                    const tx = particles[sig.to].x;
                    const ty = particles[sig.to].y;

                    const px = fx + (tx - fx) * progress;
                    const py = fy + (ty - fy) * progress;

                    const baseAlpha = 0.9 + 0.1 * Math.sin(time * FLOOD_LINE_PULSE_SPEED + sig.dist * 0.02);

                    addThickLineVerts(fx, fy, px, py, LINE_THICKNESS_PX * dpr, baseAlpha, floodPositions, floodAlphas);

                    const headBrightness = 0.9 + 0.1 * Math.sin(time * FLOOD_HEAD_PULSE_SPEED + sig.dist * 0.015);
                    addNodeQuad(px, py, FLOOD_HEAD_SIZE / 2, 0, 1, 1, headBrightness,
                                headPositions, headColors, headCenters);
                });

                if (floodPositions.length > 0 && lineProgram) {
                    gl.useProgram(lineProgram);
                    gl.uniformMatrix3fv(gl.getUniformLocation(lineProgram, 'uProjection'), false, getProjection());
                    const pulse = 0.3 * Math.sin(time * FLOOD_LINE_PULSE_SPEED);
                    gl.uniform4f(gl.getUniformLocation(lineProgram, 'uColor'), 
                                 0.1 + pulse, 0.9 + pulse*1.2, 1.0 + pulse*0.8, 1.0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, linePositionBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(floodPositions), gl.DYNAMIC_DRAW);
                    gl.enableVertexAttribArray(0);
                    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, lineAlphaBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(floodAlphas), gl.DYNAMIC_DRAW);
                    gl.enableVertexAttribArray(1);
                    gl.vertexAttribPointer(1, 1, gl.FLOAT, false, 0, 0);

                    gl.drawArrays(gl.TRIANGLES, 0, floodPositions.length / 2);
                }

                if (headPositions.length > 0 && particleProgram) {
                    gl.useProgram(particleProgram);
                    gl.uniformMatrix3fv(gl.getUniformLocation(particleProgram, 'uProjection'), false, getProjection());

                    gl.bindBuffer(gl.ARRAY_BUFFER, particlePositionBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(headPositions), gl.DYNAMIC_DRAW);
                    const posLoc = gl.getAttribLocation(particleProgram, 'aPosition');
                    gl.enableVertexAttribArray(posLoc);
                    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, particleColorBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(headColors), gl.DYNAMIC_DRAW);
                    const colLoc = gl.getAttribLocation(particleProgram, 'aColor');
                    gl.enableVertexAttribArray(colLoc);
                    gl.vertexAttribPointer(colLoc, 4, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, particleCenterBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(headCenters), gl.DYNAMIC_DRAW);
                    const cenLoc = gl.getAttribLocation(particleProgram, 'aCenter');
                    gl.enableVertexAttribArray(cenLoc);
                    gl.vertexAttribPointer(cenLoc, 2, gl.FLOAT, false, 0, 0);

                    gl.drawArrays(gl.TRIANGLES, 0, headPositions.length / 2);
                }
            }

            function getProjection() {
                return new Float32Array([
                    2 / window.innerWidth, 0, 0,
                    0, -2 / window.innerHeight, 0,
                    -1, 1, 1
                ]);
            }

            function hue2rgb(p, q, t) {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            }

            // Initial setup
            resize();
            window.addEventListener('resize', resize);

            animate(0);
        })();
    </script>
</body>
</html>
