<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, interactive-widget=resizes-content">
    <meta name="theme-color" content="#000814">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>KC3EFJ</title>
    <style>
        html {
            /* Setting a solid background color here prevents the white bar 
               if the viewport dynamic height (dvh) miscalculates */
            background-color: #000814; 
            height: 100dvh;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            /* background-attachment: fixed ensures the gradient doesn't "stretch" or 
               show white when the address bar hides/shows */
            background: linear-gradient(to bottom, #0a0015, #000814) fixed;
            height: 100dvh;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            color: #e0f7ff;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            touch-action: manipulation;
            cursor: default;
            -webkit-tap-highlight-color: transparent;
        }
        .callsign-container,
        .callsign {
            cursor: pointer;
        }
        canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: auto;
        }
        .content-wrapper {
            pointer-events: none;
            z-index: 2;
            position: relative;
            width: 100%;
            max-width: 90vw;
            padding: 20px;
            text-align: center;
            min-height: 60dvh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .blurb,
        .callsign-container {
            pointer-events: auto;
        }
        .callsign-container {
            transition: transform 0.6s cubic-bezier(0.22, 1, 0.36, 1);
            will-change: transform;
        }
        .callsign-container.expanded {
            transform: translateY(-240px);
        }
        .callsign {
            font-size: clamp(3rem, 12vw, 6rem);
            letter-spacing: 0.6rem;
            font-weight: bold;
            text-shadow: 
                0 0 10px #ff00ff,
                0 0 25px #00ffff,
                0 0 40px #ff00ff;
            margin: 0;
            transition: transform 0.4s ease, text-shadow 0.4s ease;
        }
        .callsign:hover, .callsign:active {
            transform: scale(1.04);
            text-shadow: 
                0 0 20px #ff00ff,
                0 0 40px #00ffff,
                0 0 60px #ff00ff;
        }
        .blurb {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) translateY(80px);
            opacity: 0;
            visibility: hidden;
            width: 90%;
            max-width: 600px;
            padding: clamp(1rem, 4vw, 1.8rem) clamp(1.2rem, 5vw, 2rem);
            background: rgba(10, 25, 50, 0.02);
            border-radius: 16px;
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(0, 255, 255, 0.15);
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            font-size: clamp(0.9rem, 3.2vw, 1.25rem);
            line-height: 1.5;
            text-align: center;
            text-shadow: 0 0 6px #00ffff;
            transition: opacity 0.6s ease-out, transform 0.6s cubic-bezier(0.22, 1, 0.36, 1);
            will-change: opacity, transform;
            pointer-events: auto;
            user-select: text;
            -webkit-user-select: text;
            cursor: text;
        }
        .blurb.visible {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -50%) translateY(0);
        }
        .blurb strong {
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }
        .blurb strong a,
        .blurb a strong {
            color: inherit;
            text-decoration: none;
        }
        @media (max-width: 600px) {
            .callsign-container.expanded { transform: translateY(-180px); }
            .callsign { letter-spacing: 0.4rem; }
            .blurb { padding: clamp(0.9rem, 4vw, 1.4rem) clamp(1rem, 4.5vw, 1.6rem); }
        }
        @media (max-width: 400px) {
            .blurb {
                font-size: clamp(0.85rem, 3.8vw, 1rem);
                padding: 0.8rem 1.2rem;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="content-wrapper" id="wrapper">
        <div class="callsign-container" id="callsignContainer">
            <div class="callsign" id="callsign">KC3EFJ</div>
        </div>
        <div class="blurb" id="blurb">
            Amateur Radio Operator<br>
            Based in <strong>Port Saint John</strong> (Cocoa), Florida.<br><br>
            Name: <strong>Jeff Hopkins</strong><br>
            Callsign: <strong>KC3EFJ</strong><br>
            Interests: Digital Modes, APRS, Meshtastic, Eurorack<br><br>
            Email: <strong><a href="mailto:jeff.m.hopkins+kc3efj@gmail.com">jeff.m.hopkins+kc3efj@gmail.com</a></strong><br>
            Github: <strong><a href="https://github.com/jeffmhopkins/">https://github.com/jeffmhopkins/</a></strong>
        </div>
    </div>

    <script>
        (function() {
            // Particle / Node settings
            const BASE_NODE_COUNT_DESKTOP = 120;
            const BASE_NODE_COUNT_MOBILE  = 120;
            const MIN_NODES               = 30;
            const MAX_NODES               = 400;

            const NODE_SPEED_DESKTOP      = 0.6;
            const NODE_SPEED_MOBILE       = 0.6;

            const NODE_SIZE_MIN           = 2;
            const NODE_SIZE_VARIANCE      = 6;

            // Connection line settings
            const LINE_THICKNESS_DESKTOP_PX   = 1.1;
            const LINE_THICKNESS_MOBILE_PX    = 1.1;
            const CONNECTION_DISTANCE_DESKTOP = 230;
            const CONNECTION_DISTANCE_MOBILE  = 230;

            const STATIC_LINE_ALPHA_BASE  = 0.6;
            const MOUSE_LINE_ALPHA_BASE   = 0.95;

            // Color hue ranges
            const HUE_RANGE_1_START       = 180;
            const HUE_RANGE_1_WIDTH       = 30;
            const HUE_RANGE_2_START       = 240;
            const HUE_RANGE_2_WIDTH       = 60;
            const HUE_RANGE_3_START       = 270;
            const HUE_RANGE_3_WIDTH       = 30;

            const SATURATION_BASE         = 0.5;
            const SATURATION_VARIANCE     = 1.0;

            // Flood / signal pulse settings
            const SIGNAL_SPEED            = 150;
            const FLOOD_HEAD_SIZE         = 6;
            const FLOOD_LINE_PULSE_SPEED  = 0.008;
            const FLOOD_HEAD_PULSE_SPEED  = 0.012;

            const CLEAR_ALPHA             = 0.09;
            const CLICK_SNAP_DISTANCE_SQ  = 60 * 60;

            const callsign = document.getElementById('callsign');
            const callsignContainer = document.getElementById('callsignContainer');
            const blurb = document.getElementById('blurb');

            function toggleBlurb(e) {
                e.preventDefault();
                e.stopPropagation();
                blurb.classList.toggle('visible');
                callsignContainer.classList.toggle('expanded');
            }

            callsign.addEventListener('click', toggleBlurb);
            callsign.addEventListener('touchstart', toggleBlurb, { passive: false });

            blurb.addEventListener('click', e => e.stopPropagation());
            blurb.addEventListener('touchstart', e => e.stopPropagation(), { passive: true });

            const canvas = document.getElementById('canvas');
            const gl = canvas.getContext('webgl');
            if (!gl) return;

            let width, height, dpr, particles = [], isMobile = false;
            let mouseX = -1000, mouseY = -1000;
            let signals = [];
            let activated = new Set();

            document.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
            document.addEventListener('touchmove', e => {
                if (e.touches.length > 0) {
                    mouseX = e.touches[0].clientX;
                    mouseY = e.touches[0].clientY;
                }
            }, { passive: true });
            document.addEventListener('touchstart', e => {
                if (e.touches.length > 0) {
                    mouseX = e.touches[0].clientX;
                    mouseY = e.touches[0].clientY;
                }
            }, { passive: true });

            const baseWidth = 1920, baseHeight = 1080;
            const baseDensityDesktop = BASE_NODE_COUNT_DESKTOP / (baseWidth * baseHeight);
            const baseDensityMobile  = BASE_NODE_COUNT_MOBILE  / (baseWidth * baseHeight);

            function resize() {
                dpr = window.devicePixelRatio || 1;
                width = canvas.width = window.innerWidth * dpr;
                height = canvas.height = window.innerHeight * dpr;
                canvas.style.width = window.innerWidth + 'px';
                canvas.style.height = window.innerHeight + 'px';
                gl.viewport(0, 0, width, height);

                isMobile = window.innerWidth <= 768 || 'ontouchstart' in window;
                const density = isMobile ? baseDensityMobile : baseDensityDesktop;
                const count = Math.max(MIN_NODES, Math.min(MAX_NODES, Math.round(density * (window.innerWidth * window.innerHeight))));

                initParticles(count);
            }

            window.addEventListener('resize', resize);
            resize();

            const vsSource = `
                attribute vec2 aPosition;
                attribute vec4 aColor;
                attribute float aSize;
                varying vec4 vColor;
                uniform mat3 uProjection;
                void main() {
                    vec3 pos3 = uProjection * vec3(aPosition, 1.0);
                    gl_Position = vec4(pos3.xy, 0.0, 1.0);
                    vColor = aColor;
                    gl_PointSize = aSize;
                }
            `;

            const fsSource = `
                precision mediump float;
                varying vec4 vColor;
                void main() {
                    vec2 coord = gl_PointCoord - vec2(0.5);
                    if (length(coord) > 0.5) discard;
                    gl_FragColor = vColor;
                }
            `;

            const lineVsSource = `
                attribute vec2 aPosition;
                attribute float aAlpha;
                varying float vAlpha;
                uniform mat3 uProjection;
                void main() {
                    vec3 pos3 = uProjection * vec3(aPosition, 1.0);
                    gl_Position = vec4(pos3.xy, 0.0, 1.0);
                    vAlpha = aAlpha;
                }
            `;

            const lineFsSource = `
                precision mediump float;
                varying float vAlpha;
                uniform vec4 uColor;
                void main() {
                    gl_FragColor = uColor * vec4(1.0, 1.0, 1.0, vAlpha);
                }
            `;

            function createShader(type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                return shader;
            }

            function createProgram(vs, fs) {
                const program = gl.createProgram();
                gl.attachShader(program, vs);
                gl.attachShader(program, fs);
                gl.linkProgram(program);
                return program;
            }

            const particleProgram = createProgram(createShader(gl.VERTEX_SHADER, vsSource), createShader(gl.FRAGMENT_SHADER, fsSource));
            const lineProgram = createProgram(createShader(gl.VERTEX_SHADER, lineVsSource), createShader(gl.FRAGMENT_SHADER, lineFsSource));

            const particlePositionBuffer = gl.createBuffer();
            const particleColorBuffer    = gl.createBuffer();
            const particleSizeBuffer     = gl.createBuffer();
            const linePositionBuffer     = gl.createBuffer();
            const lineAlphaBuffer        = gl.createBuffer();

            function getProjection() {
                return new Float32Array([
                    2 / window.innerWidth, 0, 0,
                    0, -2 / window.innerHeight, 0,
                    -1, 1, 1
                ]);
            }

            function initParticles(count) {
                const nodeSpeed = isMobile ? NODE_SPEED_MOBILE : NODE_SPEED_DESKTOP;
                particles = Array.from({length: count}, () => {
                    const t = Math.random();
                    let hue;
                    if (t < 0.4) {
                        hue = HUE_RANGE_1_START + (t / 0.4) * HUE_RANGE_1_WIDTH;
                    } else if (t < 0.6) {
                        hue = HUE_RANGE_2_START + (t - 0.4) / 0.2 * HUE_RANGE_2_WIDTH;
                    } else {
                        hue = HUE_RANGE_3_START + ((t - 0.6) / 0.4) * HUE_RANGE_3_WIDTH;
                    }
                    const saturation = SATURATION_BASE + Math.abs(t - 0.5) * SATURATION_VARIANCE;
                    return {
                        x: Math.random() * window.innerWidth,
                        y: Math.random() * window.innerHeight,
                        vx: (Math.random() - 0.5) * nodeSpeed,
                        vy: (Math.random() - 0.5) * nodeSpeed,
                        hue: hue,
                        sat: saturation,
                        visualSize: NODE_SIZE_MIN + Math.random() * NODE_SIZE_VARIANCE
                    };
                });
            }

            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

            function addThickLineVerts(x1, y1, x2, y2, thickness, alpha, outPositions, outAlphas) {
                const dx = x2 - x1, dy = y2 - y1;
                const len = Math.hypot(dx, dy);
                if (len < 0.001) return;
                const ux = dx / len, uy = dy / len;
                const px = -uy, py = ux;
                const hx = px * (thickness / 2), hy = py * (thickness / 2);
                outPositions.push(x1 - hx, y1 - hy, x1 + hx, y1 + hy, x2 + hx, y2 + hy);
                outPositions.push(x1 - hx, y1 - hy, x2 + hx, y2 + hy, x2 - hx, y2 - hy);
                for (let i = 0; i < 6; i++) outAlphas.push(alpha);
            }

            let lastTime = 0;
            const targetFPS = isMobile ? 1000/45 : 1000/60;

            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left, clickY = e.clientY - rect.top;
                let minDist = Infinity, closest = -1;
                particles.forEach((p, i) => {
                    const d2 = (p.x - clickX)**2 + (p.y - clickY)**2;
                    if (d2 < minDist) { minDist = d2; closest = i; }
                });
                if (minDist < CLICK_SNAP_DISTANCE_SQ) startFlood(closest);
            });

            function startFlood(startIndex) {
                signals = [];
                activated = new Set([startIndex]);
                addSignalsFrom(startIndex, performance.now());
            }

            function addSignalsFrom(index, startTime) {
                const maxDist = isMobile ? CONNECTION_DISTANCE_MOBILE : CONNECTION_DISTANCE_DESKTOP;
                for (let j = 0; j < particles.length; j++) {
                    if (j === index || activated.has(j)) continue;
                    const dist = Math.hypot(particles[index].x - particles[j].x, particles[index].y - particles[j].y);
                    if (dist < maxDist) {
                        signals.push({ from: index, to: j, start_time: startTime, duration: (dist / SIGNAL_SPEED) * 1000, dist: dist });
                    }
                }
            }

            function animate(time) {
                requestAnimationFrame(animate);
                if (!lastTime) lastTime = time;
                const delta = time - lastTime;
                if (delta < targetFPS) return;
                lastTime = time - (delta % targetFPS);

                gl.clearColor(0, 0, 20/255, CLEAR_ALPHA);
                gl.clear(gl.COLOR_BUFFER_BIT);

                particles.forEach(p => {
                    p.x += p.vx; p.y += p.vy;
                    if (p.x < 0 || p.x > window.innerWidth) p.vx *= -1;
                    if (p.y < 0 || p.y > window.innerHeight) p.vy *= -1;
                });

                const posData = new Float32Array(particles.length * 2);
                const colData = new Float32Array(particles.length * 4);
                const sizeData = new Float32Array(particles.length);

                particles.forEach((p, i) => {
                    posData[i*2] = p.x; posData[i*2+1] = p.y;
                    const h = p.hue / 360, q = p.sat;
                    colData[i*4] = hue2rgb(0, q, h + 1/3); colData[i*4+1] = hue2rgb(0, q, h);
                    colData[i*4+2] = hue2rgb(0, q, h - 1/3); colData[i*4+3] = 1;
                    sizeData[i] = p.visualSize * dpr;
                });

                gl.useProgram(particleProgram);
                gl.uniformMatrix3fv(gl.getUniformLocation(particleProgram, 'uProjection'), false, getProjection());
                gl.bindBuffer(gl.ARRAY_BUFFER, particlePositionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, posData, gl.DYNAMIC_DRAW);
                gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, particleColorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, colData, gl.DYNAMIC_DRAW);
                gl.enableVertexAttribArray(1); gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, particleSizeBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, sizeData, gl.DYNAMIC_DRAW);
                gl.enableVertexAttribArray(2); gl.vertexAttribPointer(2, 1, gl.FLOAT, false, 0, 0);
                gl.drawArrays(gl.POINTS, 0, particles.length);

                const maxDist = isMobile ? CONNECTION_DISTANCE_MOBILE : CONNECTION_DISTANCE_DESKTOP;
                const linePositions = [], lineAlphas = [];
                const lineThickness = (isMobile ? LINE_THICKNESS_MOBILE_PX : LINE_THICKNESS_DESKTOP_PX) * dpr;

                for (let i = 0; i < particles.length; i++) {
                    for (let j = i + 1; j < particles.length; j++) {
                        const d = Math.hypot(particles[i].x - particles[j].x, particles[i].y - particles[j].y);
                        if (d < maxDist) {
                            addThickLineVerts(particles[i].x, particles[i].y, particles[j].x, particles[j].y, lineThickness, (1 - d/maxDist)**1.3 * STATIC_LINE_ALPHA_BASE, linePositions, lineAlphas);
                        }
                    }
                }

                if (mouseX >= 0 && mouseX <= window.innerWidth && mouseY >= 0 && mouseY <= window.innerHeight) {
                    particles.forEach(p => {
                        const d = Math.hypot(mouseX - p.x, mouseY - p.y);
                        if (d < maxDist) addThickLineVerts(mouseX, mouseY, p.x, p.y, lineThickness, (1 - d/maxDist)**1.3 * MOUSE_LINE_ALPHA_BASE, linePositions, lineAlphas);
                    });
                }

                if (linePositions.length > 0) {
                    gl.useProgram(lineProgram);
                    gl.uniformMatrix3fv(gl.getUniformLocation(lineProgram, 'uProjection'), false, getProjection());
                    gl.uniform4f(gl.getUniformLocation(lineProgram, 'uColor'), 0.7, 0.1, 0.9, 1.0);
                    gl.bindBuffer(gl.ARRAY_BUFFER, linePositionBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(linePositions), gl.DYNAMIC_DRAW);
                    gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
                    gl.bindBuffer(gl.ARRAY_BUFFER, lineAlphaBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lineAlphas), gl.DYNAMIC_DRAW);
                    gl.enableVertexAttribArray(1); gl.vertexAttribPointer(1, 1, gl.FLOAT, false, 0, 0);
                    gl.drawArrays(gl.TRIANGLES, 0, linePositions.length / 2);
                }

                let completed = [];
                signals = signals.filter(sig => {
                    const elapsed = time - sig.start_time;
                    if (elapsed > sig.duration) {
                        if (!activated.has(sig.to)) { activated.add(sig.to); completed.push({to: sig.to, arrival: sig.start_time + sig.duration}); }
                        return false;
                    }
                    return true;
                });
                completed.forEach(c => addSignalsFrom(c.to, c.arrival));

                const floodPos = [], floodAlphas = [], hPos = [], hCol = [], hSize = [];
                signals.forEach(sig => {
                    const p = Math.min(1, Math.max(0, (time - sig.start_time) / sig.duration));
                    const fx = particles[sig.from].x, fy = particles[sig.from].y, tx = particles[sig.to].x, ty = particles[sig.to].y;
                    const px = fx + (tx - fx) * p, py = fy + (ty - fy) * p;
                    addThickLineVerts(fx, fy, px, py, lineThickness, 0.9 + 0.1 * Math.sin(time * FLOOD_LINE_PULSE_SPEED + sig.dist * 0.02), floodPos, floodAlphas);
                    hPos.push(px, py); hCol.push(0, 1, 1, 0.9 + 0.1 * Math.sin(time * FLOOD_HEAD_PULSE_SPEED + sig.dist * 0.015)); hSize.push(FLOOD_HEAD_SIZE * dpr);
                });

                if (floodPos.length > 0) {
                    gl.useProgram(lineProgram);
                    gl.uniformMatrix3fv(gl.getUniformLocation(lineProgram, 'uProjection'), false, getProjection());
                    const pulse = 0.3 * Math.sin(time * FLOOD_LINE_PULSE_SPEED);
                    gl.uniform4f(gl.getUniformLocation(lineProgram, 'uColor'), 0.1 + pulse, 0.9 + pulse*1.2, 1.0 + pulse*0.8, 1.0);
                    gl.bindBuffer(gl.ARRAY_BUFFER, linePositionBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(floodPos), gl.DYNAMIC_DRAW);
                    gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
                    gl.bindBuffer(gl.ARRAY_BUFFER, lineAlphaBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(floodAlphas), gl.DYNAMIC_DRAW);
                    gl.enableVertexAttribArray(1); gl.vertexAttribPointer(1, 1, gl.FLOAT, false, 0, 0);
                    gl.drawArrays(gl.TRIANGLES, 0, floodPos.length / 2);
                }

                if (hPos.length > 0) {
                    gl.useProgram(particleProgram);
                    gl.uniformMatrix3fv(gl.getUniformLocation(particleProgram, 'uProjection'), false, getProjection());
                    gl.bindBuffer(gl.ARRAY_BUFFER, particlePositionBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(hPos), gl.DYNAMIC_DRAW);
                    gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
                    gl.bindBuffer(gl.ARRAY_BUFFER, particleColorBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(hCol), gl.DYNAMIC_DRAW);
                    gl.enableVertexAttribArray(1); gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);
                    gl.bindBuffer(gl.ARRAY_BUFFER, particleSizeBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(hSize), gl.DYNAMIC_DRAW);
                    gl.enableVertexAttribArray(2); gl.vertexAttribPointer(2, 1, gl.FLOAT, false, 0, 0);
                    gl.drawArrays(gl.POINTS, 0, hPos.length / 2);
                }
            }

            function hue2rgb(p, q, t) {
                if (t < 0) t += 1; if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            }
            animate(0);
        })();
    </script>
</body>
</html>
