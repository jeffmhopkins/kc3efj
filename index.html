<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KC3EFJ</title>
    <style>
        html, body {
            height: 100dvh;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            background: linear-gradient(to bottom, #0a0015, #000814);
            font-family: 'Courier New', Courier, monospace;
            color: #e0f7ff;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            touch-action: manipulation;
            cursor: default;                          /* normal arrow everywhere by default */
            -webkit-tap-highlight-color: transparent;
        }
        /* Pointer cursor only on interactive elements */
        .callsign-container,
        .callsign {
            cursor: pointer;
        }
        canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        .content-wrapper {
            z-index: 2;
            position: relative;
            width: 100%;
            max-width: 90vw;
            padding: 20px;
            text-align: center;
            min-height: 60dvh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .callsign-container {
            transition: transform 0.6s cubic-bezier(0.22, 1, 0.36, 1);
            will-change: transform;
        }
        .callsign-container.expanded {
            transform: translateY(-240px);
        }
        .callsign {
            font-size: clamp(3rem, 12vw, 6rem);
            letter-spacing: 0.6rem;
            font-weight: bold;
            text-shadow: 
                0 0 10px #ff00ff,
                0 0 25px #00ffff,
                0 0 40px #ff00ff;
            margin: 0;
            transition: transform 0.4s ease, text-shadow 0.4s ease;
        }
        .callsign:hover, .callsign:active {
            transform: scale(1.04);
            text-shadow: 
                0 0 20px #ff00ff,
                0 0 40px #00ffff,
                0 0 60px #ff00ff;
        }
        .blurb {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) translateY(80px);
            opacity: 0;
            visibility: hidden;
            width: 90%;
            max-width: 600px;
            padding: clamp(1rem, 4vw, 1.8rem) clamp(1.2rem, 5vw, 2rem);
            background: rgba(10, 25, 50, 0.12);
            border-radius: 16px;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(0, 255, 255, 0.15);
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            font-size: clamp(0.9rem, 3.2vw, 1.25rem);
            line-height: 1.5;
            text-align: center;
            text-shadow: 0 0 6px #00ffff;
            transition: opacity 0.6s ease-out, transform 0.6s cubic-bezier(0.22, 1, 0.36, 1);
            will-change: opacity, transform;
            pointer-events: auto;
            user-select: text;
            -webkit-user-select: text;
            cursor: text;                                 /* text cursor for selection inside blurb */
        }
        .blurb.visible {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -50%) translateY(0);
        }
        .blurb strong {
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }
        @media (max-width: 600px) {
            .callsign-container.expanded { transform: translateY(-180px); }
            .callsign { letter-spacing: 0.4rem; }
            .blurb { padding: clamp(0.9rem, 4vw, 1.4rem) clamp(1rem, 4.5vw, 1.6rem); }
        }
        @media (max-width: 400px) {
            .blurb {
                font-size: clamp(0.85rem, 3.8vw, 1rem);
                padding: 0.8rem 1.2rem;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="content-wrapper" id="wrapper">
        <div class="callsign-container" id="callsignContainer">
            <div class="callsign" id="callsign">KC3EFJ</div>
        </div>
        <div class="blurb" id="blurb">
            Amateur Radio Operator<br>
            Based in <strong>Port Saint John</strong> (Cocoa), Florida.<br><br>
            Callsign: <strong>KC3EFJ</strong><br>
            Interests: Digital Modes, APRS, Meshtastic, Eurorack<br><br>
            Contact: <strong>@jeffmhopkins</strong> on X<br>
            Email: <strong>jeff.m.hopkins+kc3efj@gmail.com</strong>
        </div>
    </div>

    <script>
        (function() {
            const callsign = document.getElementById('callsign');
            const callsignContainer = document.getElementById('callsignContainer');
            const blurb = document.getElementById('blurb');

            function toggleBlurb(e) {
                e.preventDefault();
                e.stopPropagation();

                const isVisible = blurb.classList.contains('visible');

                if (isVisible) {
                    blurb.classList.remove('visible');
                    callsignContainer.classList.remove('expanded');
                } else {
                    blurb.classList.add('visible');
                    callsignContainer.classList.add('expanded');
                }
            }

            // Toggle only on direct callsign interaction
            callsign.addEventListener('click', toggleBlurb);
            callsign.addEventListener('touchstart', toggleBlurb, { passive: false });

            // Prevent blurb events from bubbling
            blurb.addEventListener('click', e => e.stopPropagation());
            blurb.addEventListener('touchstart', e => e.stopPropagation(), { passive: true });

            const canvas = document.getElementById('canvas');
            const gl = canvas.getContext('webgl');
            if (!gl) {
                console.error('WebGL not supported');
                const msg = document.createElement('div');
                msg.style.cssText = 'position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); color:#ff3366; font-size:1.5rem; text-align:center; padding:2rem; background:rgba(0,0,0,0.7); border-radius:12px; z-index:10;';
                msg.textContent = 'WebGL is not supported in this browser.';
                document.body.appendChild(msg);
                return;
            }

            let width, height, dpr, particles = [], isMobile = false;

            const baseWidth = 1920;
            const baseHeight = 1080;
            const baseCountDesktop = 120;
            const baseCountMobile = 70;
            const baseDensityDesktop = baseCountDesktop / (baseWidth * baseHeight);
            const baseDensityMobile = baseCountMobile / (baseWidth * baseHeight);

            function resize() {
                dpr = window.devicePixelRatio || 1;
                width = canvas.width = window.innerWidth * dpr;
                height = canvas.height = window.innerHeight * dpr;
                canvas.style.width = window.innerWidth + 'px';
                canvas.style.height = window.innerHeight + 'px';
                gl.viewport(0, 0, width, height);

                isMobile = window.innerWidth <= 768 || ('ontouchstart' in window);
                const density = isMobile ? baseDensityMobile : baseDensityDesktop;
                const targetCount = Math.round(density * (window.innerWidth * window.innerHeight));
                const count = Math.max(30, Math.min(400, targetCount));

                initParticles(count);
            }

            window.addEventListener('resize', resize);
            resize();

            // Shaders (unchanged)
            const vsSource = `
                attribute vec2 aPosition;
                attribute vec4 aColor;
                varying vec4 vColor;
                uniform mat3 uProjection;
                void main() {
                    vec3 pos3 = uProjection * vec3(aPosition, 1.0);
                    gl_Position = vec4(pos3.xy, 0.0, 1.0);
                    vColor = aColor;
                    gl_PointSize = 6.0;
                }
            `;

            const fsSource = `
                precision mediump float;
                varying vec4 vColor;
                void main() {
                    gl_FragColor = vColor;
                }
            `;

            const lineVsSource = `
                attribute vec2 aPosition;
                attribute float aAlpha;
                varying float vAlpha;
                uniform mat3 uProjection;
                void main() {
                    vec3 pos3 = uProjection * vec3(aPosition, 1.0);
                    gl_Position = vec4(pos3.xy, 0.0, 1.0);
                    vAlpha = aAlpha;
                }
            `;

            const lineFsSource = `
                precision mediump float;
                varying float vAlpha;
                uniform vec4 uColor;
                void main() {
                    gl_FragColor = uColor * vec4(1.0, 1.0, 1.0, vAlpha);
                }
            `;

            function createShader(type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            function createProgram(vs, fs) {
                const program = gl.createProgram();
                gl.attachShader(program, vs);
                gl.attachShader(program, fs);
                gl.linkProgram(program);
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('Program link error:', gl.getProgramInfoLog(program));
                    gl.deleteProgram(program);
                    return null;
                }
                return program;
            }

            const particleProgram = createProgram(
                createShader(gl.VERTEX_SHADER, vsSource),
                createShader(gl.FRAGMENT_SHADER, fsSource)
            );

            const lineProgram = createProgram(
                createShader(gl.VERTEX_SHADER, lineVsSource),
                createShader(gl.FRAGMENT_SHADER, lineFsSource)
            );

            const particlePositionBuffer = gl.createBuffer();
            const particleColorBuffer    = gl.createBuffer();
            const linePositionBuffer     = gl.createBuffer();
            const lineAlphaBuffer        = gl.createBuffer();

            function getProjection() {
                return new Float32Array([
                    2 / window.innerWidth, 0, 0,
                    0, -2 / window.innerHeight, 0,
                    -1, 1, 1
                ]);
            }

            function initParticles(count) {
                particles = Array.from({length: count}, () => ({
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight,
                    vx: (Math.random() - 0.5) * (isMobile ? 0.4 : 0.6),
                    vy: (Math.random() - 0.5) * (isMobile ? 0.4 : 0.6),
                    hue: Math.random() * 60 + 180
                }));
            }

            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

            let lastTime = 0;
            const targetFPS = isMobile ? 1000/40 : 1000/60;

            function animate(time) {
                requestAnimationFrame(animate);
                if (!lastTime) lastTime = time;
                const delta = time - lastTime;
                if (delta < targetFPS) return;
                lastTime = time - (delta % targetFPS);

                gl.clearColor(0, 0, 20/255, 0.08);
                gl.clear(gl.COLOR_BUFFER_BIT);

                particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    if (p.x < 0 || p.x > window.innerWidth) p.vx *= -1;
                    if (p.y < 0 || p.y > window.innerHeight) p.vy *= -1;
                });

                const posData = new Float32Array(particles.length * 2);
                const colData = new Float32Array(particles.length * 4);

                particles.forEach((p, i) => {
                    posData[i*2]   = p.x;
                    posData[i*2+1] = p.y;

                    const h = p.hue / 360;
                    const q = 0.7 < 0.5 ? 0.7 * 1.7 : 0.7 + 1 - 0.7;
                    const pp = 1.4 - q;
                    colData[i*4]   = hue2rgb(pp, q, h + 1/3);
                    colData[i*4+1] = hue2rgb(pp, q, h);
                    colData[i*4+2] = hue2rgb(pp, q, h - 1/3);
                    colData[i*4+3] = 1;
                });

                gl.useProgram(particleProgram);
                gl.uniformMatrix3fv(gl.getUniformLocation(particleProgram, 'uProjection'), false, getProjection());

                gl.bindBuffer(gl.ARRAY_BUFFER, particlePositionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, posData, gl.DYNAMIC_DRAW);
                gl.enableVertexAttribArray(0);
                gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, particleColorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, colData, gl.DYNAMIC_DRAW);
                gl.enableVertexAttribArray(1);
                gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

                gl.drawArrays(gl.POINTS, 0, particles.length);

                const maxDist = isMobile ? 110 * 1.333 : 160 * 1.333;
                const lines = [];
                const alphas = [];

                for (let i = 0; i < particles.length; i++) {
                    for (let j = i + 1; j < particles.length; j++) {
                        const dx = particles[i].x - particles[j].x;
                        const dy = particles[i].y - particles[j].y;
                        const d2 = dx*dx + dy*dy;
                        const maxD2 = maxDist * maxDist;
                        if (d2 < maxD2) {
                            const dist = Math.sqrt(d2);
                            const alpha = (1 - dist / maxDist) ** 1.2 * 0.6;
                            lines.push(particles[i].x, particles[i].y, particles[j].x, particles[j].y);
                            alphas.push(alpha, alpha);
                        }
                    }
                }

                if (lines.length > 0) {
                    gl.useProgram(lineProgram);
                    gl.uniformMatrix3fv(gl.getUniformLocation(lineProgram, 'uProjection'), false, getProjection());
                    gl.uniform4f(gl.getUniformLocation(lineProgram, 'uColor'), 0.9, 0.2, 1.0, 1.0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, linePositionBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lines), gl.DYNAMIC_DRAW);
                    gl.enableVertexAttribArray(0);
                    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, lineAlphaBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(alphas), gl.DYNAMIC_DRAW);
                    gl.enableVertexAttribArray(1);
                    gl.vertexAttribPointer(1, 1, gl.FLOAT, false, 0, 0);

                    gl.drawArrays(gl.LINES, 0, lines.length / 2);
                }
            }

            function hue2rgb(p, q, t) {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            }

            animate(0);
        })();
    </script>
</body>
</html>
