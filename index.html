<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="theme-color" content="#000814">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>KC3EFJ</title>
    <style>
        html, body {
            height: 100dvh;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            background: linear-gradient(to bottom, #0a0015, #000814);
            font-family: 'Courier New', Courier, monospace;
            color: #e0f7ff;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            touch-action: manipulation;
            cursor: default;
            -webkit-tap-highlight-color: transparent;
        }
        .callsign-container,
        .callsign {
            cursor: pointer;
        }
        canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: auto;
        }
        .content-wrapper {
            pointer-events: none;
            z-index: 2;
            position: relative;
            width: 100%;
            max-width: 90vw;
            padding: 20px;
            text-align: center;
            min-height: 60dvh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .blurb,
        .callsign-container {
            pointer-events: auto;
        }
        .callsign-container {
            transition: transform 0.6s cubic-bezier(0.22, 1, 0.36, 1);
            will-change: transform;
        }
        .callsign-container.expanded {
            transform: translateY(-240px);
        }
        .callsign {
            font-size: clamp(3rem, 12vw, 6rem);
            letter-spacing: 0.6rem;
            font-weight: bold;
            text-shadow: 
                0 0 10px #ff00ff,
                0 0 25px #00ffff,
                0 0 40px #ff00ff;
            margin: 0;
            transition: transform 0.4s ease, text-shadow 0.4s ease;
        }
        .callsign:hover, .callsign:active {
            transform: scale(1.04);
            text-shadow: 
                0 0 20px #ff00ff,
                0 0 40px #00ffff,
                0 0 60px #ff00ff;
        }
        .blurb {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) translateY(80px);
            opacity: 0;
            visibility: hidden;
            width: 90%;
            max-width: 600px;
            padding: clamp(1rem, 4vw, 1.8rem) clamp(1.2rem, 5vw, 2rem);
            background: rgba(10, 25, 50, 0.02);
            border-radius: 16px;
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(0, 255, 255, 0.15);
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            font-size: clamp(0.9rem, 3.2vw, 1.25rem);
            line-height: 1.5;
            text-align: center;
            text-shadow: 0 0 6px #00ffff;
            transition: opacity 0.6s ease-out, transform 0.6s cubic-bezier(0.22, 1, 0.36, 1);
            will-change: opacity, transform;
            pointer-events: auto;
            user-select: text;
            -webkit-user-select: text;
            cursor: text;
        }
        .blurb.visible {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -50%) translateY(0);
        }
        .blurb strong {
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }
        .blurb strong a,
        .blurb a strong {
            color: inherit;
            text-decoration: none;
        }
        @media (max-width: 600px) {
            .callsign-container.expanded { transform: translateY(-180px); }
            .callsign { letter-spacing: 0.4rem; }
            .blurb { padding: clamp(0.9rem, 4vw, 1.4rem) clamp(1rem, 4.5vw, 1.6rem); }
        }
        @media (max-width: 400px) {
            .blurb {
                font-size: clamp(0.85rem, 3.8vw, 1rem);
                padding: 0.8rem 1.2rem;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="content-wrapper" id="wrapper">
        <div class="callsign-container" id="callsignContainer">
            <div class="callsign" id="callsign">KC3EFJ</div>
        </div>
        <div class="blurb" id="blurb">
            Amateur Radio Operator<br>
            Based in <strong>Port Saint John</strong> (Cocoa), Florida.<br><br>
            Name: <strong>Jeff Hopkins</strong><br>
            Callsign: <strong>KC3EFJ</strong><br>
            Interests: Digital Modes, APRS, Meshtastic, Eurorack<br><br>
            Email: <strong><a href="mailto:jeff.m.hopkins+kc3efj@gmail.com">jeff.m.hopkins+kc3efj@gmail.com</a></strong><br>
            Github: <strong><a href="https://github.com/jeffmhopkins/">https://github.com/jeffmhopkins/</a></strong>
        </div>
    </div>

    <script>
        (function() {
            const callsign = document.getElementById('callsign');
            const callsignContainer = document.getElementById('callsignContainer');
            const blurb = document.getElementById('blurb');

            function toggleBlurb(e) {
                e.preventDefault();
                e.stopPropagation();
                blurb.classList.toggle('visible');
                callsignContainer.classList.toggle('expanded');
            }

            callsign.addEventListener('click', toggleBlurb);
            callsign.addEventListener('touchstart', toggleBlurb, { passive: false });

            blurb.addEventListener('click', e => e.stopPropagation());
            blurb.addEventListener('touchstart', e => e.stopPropagation(), { passive: true });

            const canvas = document.getElementById('canvas');
            const gl = canvas.getContext('webgl');
            if (!gl) {
                console.error('WebGL not supported');
                return;
            }

            let width, height, dpr, particles = [], isMobile = false;
            let mouseX = -1000, mouseY = -1000;
            let signals = [];
            let activated = new Set();
            const signalSpeed = 220; // slightly faster for better feel

            document.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
            document.addEventListener('touchmove', e => {
                if (e.touches.length > 0) {
                    mouseX = e.touches[0].clientX;
                    mouseY = e.touches[0].clientY;
                }
            }, { passive: true });
            document.addEventListener('touchstart', e => {
                if (e.touches.length > 0) {
                    mouseX = e.touches[0].clientX;
                    mouseY = e.touches[0].clientY;
                }
            }, { passive: true });

            const baseWidth = 1920, baseHeight = 1080;
            const baseCountDesktop = 120, baseCountMobile = 70;
            const baseDensityDesktop = baseCountDesktop / (baseWidth * baseHeight);
            const baseDensityMobile = baseCountMobile / (baseWidth * baseHeight);

            function resize() {
                dpr = window.devicePixelRatio || 1;
                width = canvas.width = window.innerWidth * dpr;
                height = canvas.height = window.innerHeight * dpr;
                canvas.style.width = window.innerWidth + 'px';
                canvas.style.height = window.innerHeight + 'px';
                gl.viewport(0, 0, width, height);

                isMobile = window.innerWidth <= 768 || 'ontouchstart' in window;
                const density = isMobile ? baseDensityMobile : baseDensityDesktop;
                const count = Math.max(30, Math.min(400, Math.round(density * (window.innerWidth * window.innerHeight))));

                initParticles(count);
            }

            window.addEventListener('resize', resize);
            resize();

            // ────────────────────────────────────────────────
            // Shaders
            // ────────────────────────────────────────────────

            const vsSource = `
                attribute vec2 aPosition;
                attribute vec4 aColor;
                varying vec4 vColor;
                uniform mat3 uProjection;
                void main() {
                    vec3 pos3 = uProjection * vec3(aPosition, 1.0);
                    gl_Position = vec4(pos3.xy, 0.0, 1.0);
                    vColor = aColor;
                    gl_PointSize = 6.0;
                }
            `;

            const fsSource = `
                precision mediump float;
                varying vec4 vColor;
                void main() {
                    vec2 coord = gl_PointCoord - vec2(0.5);
                    if (length(coord) > 0.5) discard;
                    gl_FragColor = vColor;
                }
            `;

            const lineVsSource = `
                attribute vec2 aPosition;
                attribute float aAlpha;
                varying float vAlpha;
                uniform mat3 uProjection;
                void main() {
                    vec3 pos3 = uProjection * vec3(aPosition, 1.0);
                    gl_Position = vec4(pos3.xy, 0.0, 1.0);
                    vAlpha = aAlpha;
                }
            `;

            const lineFsSource = `
                precision mediump float;
                varying float vAlpha;
                uniform vec4 uColor;
                void main() {
                    gl_FragColor = uColor * vec4(1.0, 1.0, 1.0, vAlpha);
                }
            `;

            function createShader(type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error(gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            function createProgram(vs, fs) {
                const program = gl.createProgram();
                gl.attachShader(program, vs);
                gl.attachShader(program, fs);
                gl.linkProgram(program);
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error(gl.getProgramInfoLog(program));
                    gl.deleteProgram(program);
                    return null;
                }
                return program;
            }

            const particleProgram = createProgram(
                createShader(gl.VERTEX_SHADER, vsSource),
                createShader(gl.FRAGMENT_SHADER, fsSource)
            );

            const lineProgram = createProgram(
                createShader(gl.VERTEX_SHADER, lineVsSource),
                createShader(gl.FRAGMENT_SHADER, lineFsSource)
            );

            const particlePositionBuffer = gl.createBuffer();
            const particleColorBuffer    = gl.createBuffer();
            const linePositionBuffer     = gl.createBuffer();
            const lineAlphaBuffer        = gl.createBuffer();

            function getProjection() {
                return new Float32Array([
                    2 / window.innerWidth, 0, 0,
                    0, -2 / window.innerHeight, 0,
                    -1, 1, 1
                ]);
            }

            function initParticles(count) {
                particles = Array.from({length: count}, () => ({
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight,
                    vx: (Math.random() - 0.5) * (isMobile ? 0.4 : 0.6),
                    vy: (Math.random() - 0.5) * (isMobile ? 0.4 : 0.6),
                    hue: Math.random() * 60 + 180
                }));
            }

            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

            let lastTime = 0;
            const targetFPS = isMobile ? 1000/45 : 1000/60;

            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                let minDist = Infinity;
                let closest = -1;
                particles.forEach((p, i) => {
                    const dx = p.x - clickX;
                    const dy = p.y - clickY;
                    const d2 = dx*dx + dy*dy;
                    if (d2 < minDist) {
                        minDist = d2;
                        closest = i;
                    }
                });
                if (minDist < 60*60) { // generous hit area
                    startFlood(closest);
                }
            });

            function startFlood(startIndex) {
                signals = [];
                activated = new Set([startIndex]);
                addSignalsFrom(startIndex, performance.now());
            }

            function addSignalsFrom(index, startTime) {
                const maxDist = isMobile ? 145 : 210;
                for (let j = 0; j < particles.length; j++) {
                    if (j === index || activated.has(j)) continue;
                    const dx = particles[index].x - particles[j].x;
                    const dy = particles[index].y - particles[j].y;
                    const dist = Math.hypot(dx, dy);
                    if (dist < maxDist) {
                        const duration = (dist / signalSpeed) * 1000;
                        signals.push({
                            from: index,
                            to: j,
                            start_time: startTime,
                            duration: duration,
                            dist: dist
                        });
                    }
                }
            }

            function animate(time) {
                requestAnimationFrame(animate);
                if (!lastTime) lastTime = time;
                const delta = time - lastTime;
                if (delta < targetFPS) return;
                lastTime = time - (delta % targetFPS);

                gl.clearColor(0, 0, 20/255, 0.09);
                gl.clear(gl.COLOR_BUFFER_BIT);

                // Update particles
                particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    if (p.x < 0 || p.x > window.innerWidth) p.vx *= -1;
                    if (p.y < 0 || p.y > window.innerHeight) p.vy *= -1;
                });

                // Draw normal particles
                const posData = new Float32Array(particles.length * 2);
                const colData = new Float32Array(particles.length * 4);

                particles.forEach((p, i) => {
                    posData[i*2]   = p.x;
                    posData[i*2+1] = p.y;

                    const h = p.hue / 360;
                    const q = 0.7;
                    const p_ = 1.4 - q;
                    colData[i*4]   = hue2rgb(p_, q, h + 1/3);
                    colData[i*4+1] = hue2rgb(p_, q, h);
                    colData[i*4+2] = hue2rgb(p_, q, h - 1/3);
                    colData[i*4+3] = 1;
                });

                gl.useProgram(particleProgram);
                gl.uniformMatrix3fv(gl.getUniformLocation(particleProgram, 'uProjection'), false, getProjection());
                gl.bindBuffer(gl.ARRAY_BUFFER, particlePositionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, posData, gl.DYNAMIC_DRAW);
                gl.enableVertexAttribArray(0);
                gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, particleColorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, colData, gl.DYNAMIC_DRAW);
                gl.enableVertexAttribArray(1);
                gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);
                gl.drawArrays(gl.POINTS, 0, particles.length);

                // ────────────────────────────────────────────────
                // Normal connection lines (dim purple-ish)
                // ────────────────────────────────────────────────
                const maxDist = isMobile ? 145 : 210;
                const lines = [];
                const alphas = [];

                for (let i = 0; i < particles.length; i++) {
                    for (let j = i + 1; j < particles.length; j++) {
                        const d = Math.hypot(particles[i].x - particles[j].x, particles[i].y - particles[j].y);
                        if (d < maxDist) {
                            const alpha = (1 - d / maxDist) ** 1.3 * 0.75;
                            lines.push(particles[i].x, particles[i].y, particles[j].x, particles[j].y);
                            alphas.push(alpha, alpha);
                        }
                    }
                }

                if (mouseX >= 0 && mouseY >= 0 && mouseX <= window.innerWidth && mouseY <= window.innerHeight) {
                    for (let i = 0; i < particles.length; i++) {
                        const d = Math.hypot(mouseX - particles[i].x, mouseY - particles[i].y);
                        if (d < maxDist) {
                            const alpha = (1 - d / maxDist) ** 1.3 * 0.55;
                            lines.push(mouseX, mouseY, particles[i].x, particles[i].y);
                            alphas.push(alpha, alpha);
                        }
                    }
                }

                if (lines.length > 0) {
                    gl.useProgram(lineProgram);
                    gl.uniformMatrix3fv(gl.getUniformLocation(lineProgram, 'uProjection'), false, getProjection());
                    gl.uniform4f(gl.getUniformLocation(lineProgram, 'uColor'), 0.7, 0.1, 0.9, 1.0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, linePositionBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lines), gl.DYNAMIC_DRAW);
                    gl.enableVertexAttribArray(0);
                    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, lineAlphaBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(alphas), gl.DYNAMIC_DRAW);
                    gl.enableVertexAttribArray(1);
                    gl.vertexAttribPointer(1, 1, gl.FLOAT, false, 0, 0);

                    gl.drawArrays(gl.LINES, 0, lines.length / 2);
                }

                // ────────────────────────────────────────────────
                // Flood propagation (glowing cyan lines + head)
                // ────────────────────────────────────────────────
                let completed = [];
                signals = signals.filter(sig => {
                    const elapsed = time - sig.start_time;
                    if (elapsed > sig.duration) {
                        if (!activated.has(sig.to)) {
                            activated.add(sig.to);
                            completed.push({to: sig.to, arrival: sig.start_time + sig.duration});
                        }
                        return false;
                    }
                    return true;
                });

                completed.forEach(c => addSignalsFrom(c.to, c.arrival));

                // Draw glowing flood lines
                const floodLines = [];
                const floodAlphas = [];
                const headsPos = [];
                const headsColor = [];

                signals.forEach(sig => {
                    let progress = (time - sig.start_time) / sig.duration;
                    progress = Math.min(1, Math.max(0, progress));

                    const fx = particles[sig.from].x;
                    const fy = particles[sig.from].y;
                    const tx = particles[sig.to].x;
                    const ty = particles[sig.to].y;

                    const px = fx + (tx - fx) * progress;
                    const py = fy + (ty - fy) * progress;

                    // Line from origin to current head
                    floodLines.push(fx, fy, px, py);
                    const baseAlpha = 0.9 + 0.1 * Math.sin(time * 0.008 + sig.dist * 0.02);
                    floodAlphas.push(baseAlpha, baseAlpha);

                    // Head (bright glow at tip)
                    headsPos.push(px, py);
                    const headBrightness = 0.9 + 0.1 * Math.sin(time * 0.012 + sig.dist * 0.015);
                    headsColor.push(0, 1, 1, headBrightness);
                });

                // Draw flood lines
              if (floodLines.length > 0) {
    gl.useProgram(lineProgram);
    gl.uniformMatrix3fv(gl.getUniformLocation(lineProgram, 'uProjection'), false, getProjection());
    
    // Brighter, more vivid cyan
    const pulse = 0.3 * Math.sin(time * 0.008);  // stronger pulse
    gl.uniform4f(gl.getUniformLocation(lineProgram, 'uColor'), 
        0.1 + pulse,     // R
        0.9 + pulse*1.2, // G
        1.0 + pulse*0.8, // B
        1.0);

    gl.bindBuffer(gl.ARRAY_BUFFER, linePositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(floodLines), gl.DYNAMIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, lineAlphaBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(floodAlphas.map(a => a * 1.4)), gl.DYNAMIC_DRAW); // boost alpha
    gl.enableVertexAttribArray(1);
    gl.vertexAttribPointer(1, 1, gl.FLOAT, false, 0, 0);

    gl.drawArrays(gl.LINES, 0, floodLines.length / 2);
}

                // Draw glowing heads
                if (headsPos.length > 0) {
                    gl.useProgram(particleProgram);
                    gl.uniformMatrix3fv(gl.getUniformLocation(particleProgram, 'uProjection'), false, getProjection());

                    gl.bindBuffer(gl.ARRAY_BUFFER, particlePositionBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(headsPos), gl.DYNAMIC_DRAW);
                    gl.enableVertexAttribArray(0);
                    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, particleColorBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(headsColor), gl.DYNAMIC_DRAW);
                    gl.enableVertexAttribArray(1);
                    gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

                    gl.drawArrays(gl.POINTS, 0, headsPos.length / 2);
                }
            }

            function hue2rgb(p, q, t) {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            }

            animate(0);
        })();
    </script>
</body>
</html>
